{% extends "base.html" %}

{% block title %}Live Stream{% endblock %}
{% block breadcrumb_current %}Live Stream{% endblock %}
{% block page_title %}Live Camera Stream{% endblock %}
{% block page_subtitle %}Real-time license plate detection with live annotations{% endblock %}

{% block page_actions %}
<div class="flex items-center gap-3">
	<button id="toggle-stream" class="btn btn-primary">
		<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
			<polygon points="5,3 19,12 5,21 5,3"></polygon>
		</svg>
		Start Stream
	</button>
	<button id="toggle-fullscreen" class="btn btn-outline">
		<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
			<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
		</svg>
		Fullscreen
	</button>
	<button id="capture-frame" class="btn btn-secondary">
		<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
			<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
			<circle cx="12" cy="13" r="4"></circle>
		</svg>
		Capture
	</button>
</div>
{% endblock %}

{% block extra_css %}
<style>
.stream-container {
	position: relative;
	background: #000;
	border-radius: var(--radius-lg);
	overflow: hidden;
	aspect-ratio: 16/9;
	max-height: 70vh;
}

.video-feed {
	width: 100%;
	height: 100%;
	object-fit: contain;
	display: block;
}

.stream-overlay {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	z-index: 10;
}

#detection-canvas {
	position: absolute;
	top: 0;
	left: 0;
	pointer-events: none;
	z-index: 10;
}

.detection-box {
	position: absolute;
	border: 2px solid var(--primary);
	border-radius: var(--radius);
	background: rgba(37, 99, 235, 0.1);
	transition: all 0.3s ease;
}

.detection-label {
	position: absolute;
	top: -25px;
	left: 0;
	background: var(--primary);
	color: white;
	padding: var(--space-1) var(--space-2);
	border-radius: var(--radius);
	font-size: 0.75rem;
	font-weight: 600;
	white-space: nowrap;
}

.stream-status {
	position: absolute;
	top: var(--space-4);
	right: var(--space-4);
	background: rgba(0, 0, 0, 0.5);
	color: white;
	padding: var(--space-3);
	border-radius: var(--radius-lg);
	backdrop-filter: blur(8px);
	z-index: 20;
	font-size: 0.875rem;
}

.stream-controls {
	position: absolute;
	bottom: var(--space-4);
	left: 50%;
	transform: translateX(-50%);
	display: flex;
	gap: var(--space-2);
	background: rgba(0, 0, 0, 0.5);
	padding: var(--space-3);
	border-radius: var(--radius-lg);
	backdrop-filter: blur(8px);
	z-index: 20;
	opacity: 0;
	transition: opacity 0.3s ease;
}

.stream-container:hover .stream-controls {
	opacity: 1;
}

.control-btn {
	background: rgba(255, 255, 255, 0.2);
	border: none;
	color: white;
	padding: var(--space-2);
	border-radius: var(--radius);
	cursor: pointer;
	transition: background 0.2s ease;
}

.control-btn:hover {
	background: rgba(255, 255, 255, 0.3);
}

.control-btn.active {
	background: var(--primary);
}

.stats-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
	gap: var(--space-4);
	margin-top: var(--space-6);
}

.stat-card {
	text-align: center;
}

.stat-value {
	font-size: 2rem;
	font-weight: 700;
	color: var(--primary);
	margin-bottom: var(--space-2);
}

.stat-label {
	font-size: 0.875rem;
	color: var(--gray-600);
	font-weight: 500;
}

.recent-detections {
	max-height: 400px;
	overflow-y: auto;
}

.detection-item {
	display: flex;
	align-items: center;
	gap: var(--space-3);
	padding: var(--space-3);
	border-bottom: 1px solid var(--border-light);
	transition: background-color var(--transition-fast);
}

.detection-item:hover {
	background-color: var(--gray-50);
}

.detection-thumbnail {
	width: 60px;
	height: 40px;
	border-radius: var(--radius);
	background: var(--gray-200);
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 0.75rem;
	font-weight: 600;
	color: var(--gray-600);
}

.detection-info {
	flex: 1;
}

.detection-plate {
	font-weight: 600;
	margin-bottom: var(--space-1);
}

.detection-meta {
	font-size: 0.875rem;
	color: var(--gray-600);
}

.confidence-badge {
	padding: var(--space-1) var(--space-2);
	border-radius: var(--radius-full);
	font-size: 0.75rem;
	font-weight: 600;
}

.confidence-high {
	background: var(--success);
	color: white;
}

.confidence-medium {
	background: var(--warning);
	color: white;
}

.confidence-low {
	background: var(--danger);
	color: white;
}

.fullscreen-mode {
	position: fixed !important;
	top: 0 !important;
	left: 0 !important;
	width: 100vw !important;
	height: 100vh !important;
	z-index: 9999 !important;
	background: #000 !important;
	max-height: none !important;
	border-radius: 0 !important;
	padding: 0 !important;
	margin: 0 !important;
}

.fullscreen-mode .stream-container {
	width: 100% !important;
	height: 100% !important;
	max-height: none !important;
	border-radius: 0 !important;
	aspect-ratio: unset !important;
}

@media (max-width: 768px) {
	.stats-grid {
		grid-template-columns: repeat(2, 1fr);
	}
	
	.stream-controls {
		opacity: 1;
	}
}
</style>
{% endblock %}

{% block content %}
<!-- Main Stream Grid -->
<div class="grid grid-cols-3 gap-6">
	<!-- Video Stream -->
	<div class="col-span-2">
		<div class="card" style="padding: 0; overflow: hidden;">
			<div class="stream-container" id="stream-container">
				<img id="video-feed" src="/stream/video" alt="Video Stream" class="video-feed">
				<canvas id="detection-canvas" class="stream-overlay"></canvas>
				
				<!-- Detection Overlay -->
				<div class="stream-overlay" id="detection-overlay"></div>
				
				<!-- Stream Status -->
				<div class="stream-status">
					<div class="flex items-center gap-2 mb-2">
						<div class="status status-offline" id="stream-status">
							<span class="status-dot"></span>
							<span class="status-text">Disconnected</span>
						</div>
					</div>
					<div class="text-xs opacity-75">
						FPS: <span id="fps-counter">0</span> | 
						Resolution: <span id="resolution">--x--</span>
					</div>
				</div>
				
				<!-- Stream Controls -->
				<div class="stream-controls">
					<button class="control-btn" id="play-pause" data-tooltip="Play/Pause">
						<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
							<polygon points="5,3 19,12 5,21 5,3"></polygon>
						</svg>
					</button>
					<button class="control-btn" id="toggle-detection" data-tooltip="Toggle Detection">
						<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
							<circle cx="12" cy="12" r="3"></circle>
						</svg>
					</button>
					<button class="control-btn" id="toggle-labels" data-tooltip="Toggle Labels">
						<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
							<polyline points="14,2 14,8 20,8"></polyline>
						</svg>
					</button>
					<button class="control-btn" id="settings" data-tooltip="Settings">
						<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<circle cx="12" cy="12" r="3"></circle>
							<path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
						</svg>
					</button>
				</div>
			</div>
		</div>
		
		<!-- Stream Statistics -->
		<div class="stats-grid">
			<div class="card stat-card">
				<div class="stat-value" id="detections-count">0</div>
				<div class="stat-label">Detections Today</div>
			</div>
			<div class="card stat-card">
				<div class="stat-value" id="accuracy-rate">0%</div>
				<div class="stat-label">Accuracy Rate</div>
			</div>
			<div class="card stat-card">
				<div class="stat-value" id="processing-speed">0ms</div>
				<div class="stat-label">Avg Processing</div>
			</div>
			<div class="card stat-card">
				<div class="stat-value" id="stream-quality">HD</div>
				<div class="stat-label">Stream Quality</div>
			</div>
		</div>
	</div>
	
	<!-- Recent Detections Sidebar -->
	<div class="card">
		<div class="card-header">
			<div class="flex items-center justify-between">
				<h3 class="card-title">Live Detections</h3>
				<button class="btn btn-sm btn-outline" id="clear-detections">
					Clear
				</button>
			</div>
		</div>
		<div class="card-body" style="padding: 0;">
			<div class="recent-detections" id="recent-detections">
				<div class="detection-item">
					<div class="detection-thumbnail">IMG</div>
					<div class="detection-info">
						<div class="detection-plate">Waiting for detections...</div>
						<div class="detection-meta">Start the stream to see live results</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

<!-- Settings Modal -->
<div class="modal" id="settings-modal">
	<div class="modal-content">
		<div class="modal-header">
			<h3 class="modal-title">Stream Settings</h3>
			<button class="btn btn-ghost" data-modal-close>
				<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<line x1="18" y1="6" x2="6" y2="18"></line>
					<line x1="6" y1="6" x2="18" y2="18"></line>
				</svg>
			</button>
		</div>
		<div class="modal-body">
			<div class="grid gap-4">
				<div>
					<label class="block text-sm font-medium mb-2">Confidence Threshold</label>
					<input type="range" min="0.1" max="1.0" step="0.1" value="0.5" id="confidence-slider" class="w-full">
					<div class="text-sm text-gray-600 mt-1">Current: <span id="confidence-value">0.5</span></div>
				</div>
				<div>
					<label class="block text-sm font-medium mb-2">Detection Frequency</label>
					<select id="detection-frequency" class="w-full">
						<option value="1">Every Frame</option>
						<option value="3" selected>Every 3rd Frame</option>
						<option value="5">Every 5th Frame</option>
						<option value="10">Every 10th Frame</option>
					</select>
				</div>
				<div>
					<label class="flex items-center gap-2">
						<input type="checkbox" id="auto-enhance" checked>
						<span class="text-sm">Auto-enhance detected plates</span>
					</label>
				</div>
				<div>
					<label class="flex items-center gap-2">
						<input type="checkbox" id="save-detections" checked>
						<span class="text-sm">Save detection images</span>
					</label>
				</div>
			</div>
		</div>
		<div class="modal-footer">
			<button class="btn btn-outline" data-modal-close>Cancel</button>
			<button class="btn btn-primary" id="save-settings">Save Settings</button>
		</div>
	</div>
</div>
{% endblock %}

{% block page_js %}
// Enhanced Stream Page JavaScript
class StreamPage {
	constructor() {
		this.isStreaming = true;  // Default to streaming since video loads automatically
		this.isDetectionEnabled = true;
		this.showLabels = true;
		this.streamWebSocket = null;
		this.canvas = document.getElementById('detection-canvas');
		this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
		this.videoFeed = document.getElementById('video-feed');
		this.detections = [];
		this.lastFrameTime = 0;
		this.frameCount = 0;
		
		this.init();
	}

	init() {
		this.setupEventListeners();
		this.setupWebSocket();
		this.startVideoStream();
		this.setupFullscreenListeners();
		this.initializeButtonStates();
	}
	
	initializeButtonStates() {
		// Initialize button states to match current settings
		const detectionBtn = document.getElementById('toggle-detection');
		const labelsBtn = document.getElementById('toggle-labels');
		
		if (detectionBtn) {
			detectionBtn.classList.toggle('active', this.isDetectionEnabled);
			detectionBtn.style.backgroundColor = this.isDetectionEnabled ? 'var(--primary)' : 'rgba(255, 255, 255, 0.2)';
		}
		
		if (labelsBtn) {
			labelsBtn.classList.toggle('active', this.showLabels);
			labelsBtn.style.backgroundColor = this.showLabels ? 'var(--primary)' : 'rgba(255, 255, 255, 0.2)';
		}
		
		// Update stream button
		this.updateStreamButton();
	}

	setupEventListeners() {
		// Stream controls
		document.getElementById('toggle-stream')?.addEventListener('click', () => this.toggleStream());
		document.getElementById('toggle-fullscreen')?.addEventListener('click', () => this.toggleFullscreen());
		document.getElementById('capture-frame')?.addEventListener('click', () => this.captureFrame());
		
		// Video controls
		document.getElementById('play-pause')?.addEventListener('click', () => this.togglePlayPause());
		document.getElementById('toggle-detection')?.addEventListener('click', () => this.toggleDetection());
		document.getElementById('toggle-labels')?.addEventListener('click', () => this.toggleLabels());
		document.getElementById('settings')?.addEventListener('click', () => this.openSettings());
		
		// Settings
		document.getElementById('save-settings')?.addEventListener('click', () => this.saveSettings());
		document.getElementById('clear-detections')?.addEventListener('click', () => this.clearDetections());
		
		// Modal close functionality
		document.querySelectorAll('[data-modal-close]').forEach(btn => {
			btn.addEventListener('click', () => {
				const modal = btn.closest('.modal');
				if (modal) modal.classList.remove('show');
			});
		});
		
		// Close modal on backdrop click
		document.querySelectorAll('.modal').forEach(modal => {
			modal.addEventListener('click', (e) => {
				if (e.target === modal) {
					modal.classList.remove('show');
				}
			});
		});
		
		// Video feed event listeners
		if (this.videoFeed) {
			this.videoFeed.addEventListener('load', () => this.onVideoLoad());
			this.videoFeed.addEventListener('error', () => this.onVideoError());
		}
		
		// Keyboard shortcuts
		document.addEventListener('keydown', (e) => {
			if (e.code === 'Space') {
				e.preventDefault();
				this.togglePlayPause();
			} else if (e.code === 'KeyF') {
				e.preventDefault();
				this.toggleFullscreen();
			}
		});
	}

	setupWebSocket() {
		if (window.lprApp && window.location.protocol === 'http:') {
			const wsUrl = `ws://${window.location.host}/ws/stream`;
			this.streamWebSocket = window.lprApp.createWebSocket(wsUrl, {
				id: 'stream',
				onMessage: (data) => this.handleStreamData(data),
				onOpen: () => this.onStreamConnected(),
				onClose: () => this.onStreamDisconnected()
			});
		}
	}

	startVideoStream() {
		if (this.videoFeed) {
			// Set up canvas overlay
			this.setupCanvas();
			
			// Start monitoring for stream activity
			this.startStreamMonitoring();
			
			// Initialize as connected since video feed exists
			this.updateStreamStatus('connected');
			
			// Load initial statistics
			this.loadInitialStats();
		}
	}

	async loadInitialStats() {
		// Check initial stream status
		await this.checkStreamStatus();
		
		// Load today's detection count
		await this.fetchTodayDetectionCount();
		
		// Load recent detections for display
		await this.loadRecentDetections();
		
		// Update stream quality
		this.updateSystemStats();
		
		// Start periodic stats update
		setInterval(() => {
			this.fetchTodayDetectionCount();
			this.updateProcessingSpeed();
			this.checkStreamStatus();
			this.loadRecentDetections(); // Refresh detections periodically
		}, 10000); // Update every 10 seconds
	}

	async checkStreamStatus() {
		try {
			// Check if video element is successfully loading frames
			if (this.videoFeed && this.videoFeed.complete && this.videoFeed.naturalWidth > 0) {
				this.updateStreamStatus('connected');
				this.isStreaming = true;
			} else {
				// Try to check video stream endpoint directly
				const response = await fetch('/stream/video', { method: 'HEAD' });
				if (response.ok) {
					this.updateStreamStatus('connected');
					this.isStreaming = true;
				} else {
					this.updateStreamStatus('disconnected');
					this.isStreaming = false;
				}
			}
		} catch (error) {
			console.debug('Could not check stream status:', error);
			// Default to connected if stream endpoint exists
			this.updateStreamStatus('connected');
			this.isStreaming = true;
		}
	}

	updateStreamButton() {
		const btn = document.getElementById('toggle-stream');
		if (btn) {
			btn.innerHTML = this.isStreaming ? `
				<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
					<rect x="6" y="4" width="4" height="16"></rect>
					<rect x="14" y="4" width="4" height="16"></rect>
				</svg>
				Stop Stream
			` : `
				<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<polygon points="5,3 19,12 5,21 5,3"></polygon>
				</svg>
				Start Stream
			`;
		}
	}

	setupCanvas() {
		if (!this.canvas || !this.videoFeed) return;
		
		// Make canvas overlay the video
		const updateCanvasSize = () => {
			const rect = this.videoFeed.getBoundingClientRect();
			this.canvas.width = rect.width;
			this.canvas.height = rect.height;
			this.canvas.style.position = 'absolute';
			this.canvas.style.top = '0';
			this.canvas.style.left = '0';
			this.canvas.style.pointerEvents = 'none';
		};
		
		updateCanvasSize();
		window.addEventListener('resize', updateCanvasSize);
		
		// Start detection overlay rendering
		this.startDetectionOverlay();
	}

	startStreamMonitoring() {
		// Monitor stream for activity
		setInterval(() => {
			this.frameCount++;
			this.updateStreamStats();
		}, 1000);
	}

	startDetectionOverlay() {
		const renderLoop = () => {
			if (this.ctx && this.isDetectionEnabled) {
				// Clear canvas
				this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
				
				// Draw detections
				this.drawDetections();
			}
			
			requestAnimationFrame(renderLoop);
		};
		
		renderLoop();
	}

	onVideoLoad() {
		this.updateStreamStatus('connected');
		console.log('Video stream loaded successfully');
	}

	onVideoError() {
		this.updateStreamStatus('error');
		console.error('Video stream failed to load');
	}

	updateStreamStats() {
		// Update FPS counter
		const fpsElement = document.getElementById('fps-counter');
		if (fpsElement) {
			fpsElement.textContent = '30'; // Approximate from stream
		}
		
		// Update resolution
		const resElement = document.getElementById('resolution');
		if (resElement && this.videoFeed) {
			resElement.textContent = `${this.videoFeed.naturalWidth || 1280}x${this.videoFeed.naturalHeight || 720}`;
		}
	}

	drawDetections() {
		if (!this.ctx || !this.detections.length) return;
		
		this.detections.forEach(detection => {
			const { bbox, confidence, plate_text } = detection;
			if (!bbox || bbox.length < 4) return;
			
			const [x1, y1, x2, y2] = bbox;
			const width = x2 - x1;
			const height = y2 - y1;
			
			// Scale coordinates to canvas size
			const scaleX = this.canvas.width / 1280;
			const scaleY = this.canvas.height / 720;
			
			const scaledX = x1 * scaleX;
			const scaledY = y1 * scaleY;
			const scaledWidth = width * scaleX;
			const scaledHeight = height * scaleY;
			
			// Draw bounding box
			this.ctx.strokeStyle = confidence > 0.7 ? '#10b981' : confidence > 0.4 ? '#f59e0b' : '#ef4444';
			this.ctx.lineWidth = 2;
			this.ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
			
			// Draw label if enabled
			if (this.showLabels && plate_text) {
				const label = `${plate_text} (${(confidence * 100).toFixed(1)}%)`;
				
				this.ctx.fillStyle = this.ctx.strokeStyle;
				this.ctx.fillRect(scaledX, scaledY - 25, this.ctx.measureText(label).width + 10, 20);
				
				this.ctx.fillStyle = 'white';
				this.ctx.font = '12px Arial';
				this.ctx.fillText(label, scaledX + 5, scaledY - 10);
			}
		});
	}

	handleStreamData(data) {
		if (data.type === 'detection') {
			this.addDetection(data.detection || data);
			this.updateStats(data.detection || data);
		} else if (data.type === 'frame') {
			// Handle frame data if needed
		} else if (data.type === 'system') {
			this.updateSystemStats(data);
		}
	}

	addDetection(detection) {
		// Add to detections array for overlay
		this.detections.unshift(detection);
		if (this.detections.length > 10) {
			this.detections.pop();
		}
		
		// Add to recent detections list
		this.addDetectionToList(detection);
		
		// Clear detection after 3 seconds
		setTimeout(() => {
			const index = this.detections.indexOf(detection);
			if (index > -1) {
				this.detections.splice(index, 1);
			}
		}, 3000);
	}

	addDetectionToList(detection) {
		const list = document.getElementById('recent-detections');
		if (!list) return;
		
		const item = document.createElement('div');
		item.className = 'detection-item';
		
		const confidence = detection.confidence || 0;
		const confidenceClass = confidence > 0.7 ? 'confidence-high' : 
								 confidence > 0.4 ? 'confidence-medium' : 'confidence-low';
		
		item.innerHTML = `
			<div class="detection-thumbnail">${detection.plate_text ? detection.plate_text.substring(0, 3) : 'IMG'}</div>
			<div class="detection-info">
				<div class="detection-plate">${detection.plate_text || 'Unknown'}</div>
				<div class="detection-meta">
					<span class="confidence-badge ${confidenceClass}">${(confidence * 100).toFixed(1)}%</span>
					<span style="margin-left: 8px;">Just now</span>
				</div>
			</div>
		`;
		
		list.insertBefore(item, list.firstChild);
		
		// Remove old items
		while (list.children.length > 20) {
			list.removeChild(list.lastChild);
		}
	}

	updateStats(detection) {
		// Update detection count for today
		const countEl = document.getElementById('detections-count');
		if (countEl) {
			// Fetch real count from API or increment current
			this.fetchTodayDetectionCount();
		}
		
		// Update accuracy rate (rolling average of recent detections)
		if (detection && detection.confidence) {
			this.updateAccuracyRate(detection.confidence);
		}
		
		// Update processing speed
		this.updateProcessingSpeed();
	}

	async fetchTodayDetectionCount() {
		try {
			const response = await fetch('/api/system/health');
			if (response.ok) {
				const data = await response.json();
				const countEl = document.getElementById('detections-count');
				if (countEl && data.detections) {
					countEl.textContent = data.detections.today || 0;
				}
			}
		} catch (error) {
			console.debug('Could not fetch detection count:', error);
			// Fallback to increment
			const countEl = document.getElementById('detections-count');
			if (countEl) {
				const current = parseInt(countEl.textContent) || 0;
				countEl.textContent = current + 1;
			}
		}
	}

	updateAccuracyRate(newConfidence) {
		// Store recent confidences for rolling average
		if (!this.recentConfidences) {
			this.recentConfidences = [];
		}
		
		this.recentConfidences.push(newConfidence);
		
		// Keep only last 10 detections for rolling average
		if (this.recentConfidences.length > 10) {
			this.recentConfidences.shift();
		}
		
		// Calculate average accuracy
		const avgConfidence = this.recentConfidences.reduce((sum, conf) => sum + conf, 0) / this.recentConfidences.length;
		
		const accuracyEl = document.getElementById('accuracy-rate');
		if (accuracyEl) {
			accuracyEl.textContent = `${(avgConfidence * 100).toFixed(1)}%`;
		}
	}

	updateProcessingSpeed() {
		// Update processing speed from performance data
		const processingEl = document.getElementById('processing-speed');
		if (processingEl) {
			// Get processing time from the global frame processor data
			if (window.streamPerformance && window.streamPerformance.processingTime) {
				processingEl.textContent = `${window.streamPerformance.processingTime.toFixed(0)}ms`;
			} else {
				// Fallback to estimated value
				processingEl.textContent = '150ms';
			}
		}
	}

	updateSystemStats(systemData) {
		// Update stream quality based on actual video properties
		const qualityEl = document.getElementById('stream-quality');
		if (qualityEl && this.videoFeed) {
			const width = this.videoFeed.naturalWidth || 1280;
			const height = this.videoFeed.naturalHeight || 720;
			
			if (width >= 1920) {
				qualityEl.textContent = 'Full HD';
			} else if (width >= 1280) {
				qualityEl.textContent = 'HD';
			} else {
				qualityEl.textContent = 'SD';
			}
		}
	}

	async toggleStream() {
		try {
			const btn = document.getElementById('toggle-stream');
			if (btn) {
				btn.disabled = true;
				btn.innerHTML = `
					<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<circle cx="12" cy="12" r="10"></circle>
						<path d="M8 12l2 2 4-4"></path>
					</svg>
					Processing...
				`;
			}

			if (this.isStreaming) {
				// Hide video feed
				if (this.videoFeed) {
					this.videoFeed.style.display = 'none';
				}
				this.isStreaming = false;
				this.updateStreamStatus('disconnected');
			} else {
				// Show video feed and reload
				if (this.videoFeed) {
					this.videoFeed.style.display = 'block';
					// Force reload the video stream
					const currentSrc = this.videoFeed.src;
					this.videoFeed.src = '';
					setTimeout(() => {
						this.videoFeed.src = currentSrc;
					}, 100);
				}
				this.isStreaming = true;
				this.updateStreamStatus('connected');
			}
		} catch (error) {
			console.error('Error toggling stream:', error);
		} finally {
			// Update button
			this.updateStreamButton();
			const btn = document.getElementById('toggle-stream');
			if (btn) {
				btn.disabled = false;
			}
		}
	}

	toggleFullscreen() {
		const container = document.getElementById('stream-container');
		if (!container) return;
		
		if (document.fullscreenElement) {
			document.exitFullscreen();
		} else {
			container.requestFullscreen();
		}
	}

	setupFullscreenListeners() {
		// Listen for fullscreen change events
		document.addEventListener('fullscreenchange', () => {
			const container = document.getElementById('stream-container');
			if (!container) return;
			
			if (document.fullscreenElement) {
				// Entering fullscreen
				container.classList.add('fullscreen-mode');
			} else {
				// Exiting fullscreen
				container.classList.remove('fullscreen-mode');
				
				// Force reset any lingering styles
				container.style.position = '';
				container.style.top = '';
				container.style.left = '';
				container.style.width = '';
				container.style.height = '';
				container.style.zIndex = '';
				container.style.background = '';
			}
		});
		
		// Handle escape key
		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape' && document.fullscreenElement) {
				const container = document.getElementById('stream-container');
				if (container) {
					container.classList.remove('fullscreen-mode');
				}
			}
		});
	}

	captureFrame() {
		if (!this.videoFeed) return;
		
		// Create a temporary canvas to capture the current video frame
		const tempCanvas = document.createElement('canvas');
		const tempCtx = tempCanvas.getContext('2d');
		
		// Set canvas size to match video
		tempCanvas.width = this.videoFeed.naturalWidth || 1280;
		tempCanvas.height = this.videoFeed.naturalHeight || 720;
		
		// Draw current video frame
		tempCtx.drawImage(this.videoFeed, 0, 0);
		
		// Add detection overlays if enabled
		if (this.isDetectionEnabled && this.detections.length > 0) {
			this.drawDetectionsOnCanvas(tempCtx, tempCanvas.width, tempCanvas.height);
		}
		
		// Create download link
		const link = document.createElement('a');
		link.download = `capture_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
		link.href = tempCanvas.toDataURL();
		link.click();
		
		if (window.lprApp) {
			window.lprApp.showNotification('Frame captured successfully', 'success');
		}
	}

	drawDetectionsOnCanvas(ctx, canvasWidth, canvasHeight) {
		this.detections.forEach(detection => {
			const { bbox, confidence, plate_text } = detection;
			if (!bbox || bbox.length < 4) return;
			
			const [x1, y1, x2, y2] = bbox;
			const width = x2 - x1;
			const height = y2 - y1;
			
			// Scale coordinates to canvas size
			const scaleX = canvasWidth / 1280;
			const scaleY = canvasHeight / 720;
			
			const scaledX = x1 * scaleX;
			const scaledY = y1 * scaleY;
			const scaledWidth = width * scaleX;
			const scaledHeight = height * scaleY;
			
			// Draw bounding box
			ctx.strokeStyle = confidence > 0.7 ? '#10b981' : confidence > 0.4 ? '#f59e0b' : '#ef4444';
			ctx.lineWidth = 3;
			ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
			
			// Draw label if enabled
			if (this.showLabels && plate_text) {
				const label = `${plate_text} (${(confidence * 100).toFixed(1)}%)`;
				
				ctx.fillStyle = ctx.strokeStyle;
				ctx.fillRect(scaledX, scaledY - 30, ctx.measureText(label).width + 10, 25);
				
				ctx.fillStyle = 'white';
				ctx.font = '14px Arial';
				ctx.fillText(label, scaledX + 5, scaledY - 10);
			}
		});
	}

	togglePlayPause() {
		this.toggleStream();
		
		// Update play/pause button
		const btn = document.getElementById('play-pause');
		if (btn) {
			btn.innerHTML = this.isStreaming ? `
				<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
					<rect x="6" y="4" width="4" height="16"></rect>
					<rect x="14" y="4" width="4" height="16"></rect>
				</svg>
			` : `
				<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
					<polygon points="5,3 19,12 5,21 5,3"></polygon>
				</svg>
			`;
			btn.classList.toggle('active', this.isStreaming);
		}
	}

	toggleDetection() {
		this.isDetectionEnabled = !this.isDetectionEnabled;
		const btn = document.getElementById('toggle-detection');
		if (btn) {
			btn.classList.toggle('active', this.isDetectionEnabled);
			// Update button appearance
			btn.style.backgroundColor = this.isDetectionEnabled ? 'var(--primary)' : 'rgba(255, 255, 255, 0.2)';
		}
		
		// Clear canvas if detection is disabled
		if (!this.isDetectionEnabled && this.ctx) {
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
		}
		
		console.log(`Detection overlay: ${this.isDetectionEnabled ? 'ON' : 'OFF'}`);
	}

	toggleLabels() {
		this.showLabels = !this.showLabels;
		const btn = document.getElementById('toggle-labels');
		if (btn) {
			btn.classList.toggle('active', this.showLabels);
			// Update button appearance
			btn.style.backgroundColor = this.showLabels ? 'var(--primary)' : 'rgba(255, 255, 255, 0.2)';
		}
		
		console.log(`Detection labels: ${this.showLabels ? 'ON' : 'OFF'}`);
	}

	openSettings() {
		const modal = document.getElementById('settings-modal');
		if (modal) {
			modal.classList.add('show');
		} else {
			console.log('Settings modal not found');
		}
	}

	saveSettings() {
		// Get settings values
		const confidence = document.getElementById('confidence-slider')?.value;
		const frequency = document.getElementById('detection-frequency')?.value;
		const autoEnhance = document.getElementById('auto-enhance')?.checked;
		const saveDetections = document.getElementById('save-detections')?.checked;
		
		// Save settings (implement API call)
		console.log('Saving settings:', { confidence, frequency, autoEnhance, saveDetections });
		
		// Close modal
		const modal = document.getElementById('settings-modal');
		if (modal) {
			modal.classList.remove('show');
		}
		
		console.log('Settings saved successfully');
	}

	clearDetections() {
		const list = document.getElementById('recent-detections');
		if (list) {
			list.innerHTML = `
				<div class="detection-item">
					<div class="detection-thumbnail">IMG</div>
					<div class="detection-info">
						<div class="detection-plate">No recent detections</div>
						<div class="detection-meta">Cleared by user</div>
					</div>
				</div>
			`;
		}
		this.detections = [];
	}

	updateStreamStatus(status) {
		const statusEl = document.getElementById('stream-status');
		if (statusEl) {
			statusEl.className = `status status-${status}`;
			const statusText = {
				connected: 'Connected',
				disconnected: 'Disconnected',
				error: 'Error',
				loading: 'Connecting...'
			};
			statusEl.querySelector('.status-text').textContent = statusText[status] || status;
		}
	}

	onStreamConnected() {
		this.updateStreamStatus('connected');
		console.log('Stream WebSocket connected');
	}

	onStreamDisconnected() {
		this.updateStreamStatus('disconnected');
		console.log('Stream WebSocket disconnected');
	}

	handleStreamData(data) {
		// Handle WebSocket detection data
		if (data && data.type === 'detection') {
			this.addLiveDetection(data.data);
			this.detections = [data.data]; // Update for canvas overlay
			this.updateAccuracyRate(data.data.confidence || 0);
			this.fetchTodayDetectionCount();
		}
	}

	addLiveDetection(detection) {
		const container = document.getElementById('recent-detections');
		if (!container) return;

		// Remove placeholder if it exists
		const placeholder = container.querySelector('.detection-item');
		if (placeholder && placeholder.textContent.includes('Waiting for detections')) {
			placeholder.remove();
		}

		// Create detection item
		const detectionEl = document.createElement('div');
		detectionEl.className = 'detection-item';
		detectionEl.innerHTML = `
			<div class="detection-thumbnail">
				${detection.image_path ? 
					`<img src="${detection.image_path}" alt="Detection" style="width: 100%; height: 100%; object-fit: cover; border-radius: var(--radius);">` : 
					'IMG'
				}
			</div>
			<div class="detection-info">
				<div class="detection-plate">${detection.plate_text || 'Unknown'}</div>
				<div class="detection-meta">
					<span class="confidence-badge ${this.getConfidenceClass(detection.confidence)}">
						${((detection.confidence || 0) * 100).toFixed(1)}%
					</span>
					<span style="margin-left: 8px; font-size: 0.75rem; color: var(--gray-500);">
						${new Date().toLocaleTimeString()}
					</span>
				</div>
			</div>
		`;

		// Add to container (newest first)
		container.insertBefore(detectionEl, container.firstChild);

		// Keep only last 10 detections
		while (container.children.length > 10) {
			container.removeChild(container.lastChild);
		}

		// Auto-scroll to show new detection
		detectionEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
	}

	getConfidenceClass(confidence) {
		if (confidence >= 0.7) return 'confidence-high';
		if (confidence >= 0.4) return 'confidence-medium';
		return 'confidence-low';
	}

	// Load recent detections from API for initial display
	async loadRecentDetections() {
		try {
			const response = await fetch('/api/headless/detections/recent?limit=10');
			if (response.ok) {
				const data = await response.json();
				const container = document.getElementById('recent-detections');
				if (container && data.detections && data.detections.length > 0) {
					// Clear placeholder
					container.innerHTML = '';
					
					// Add each detection (reverse to show newest first)
					data.detections.reverse().forEach(detection => {
						this.addLiveDetection(detection);
					});
				}
			}
		} catch (error) {
			console.debug('Could not load recent detections:', error);
		}
	}
}

// Initialize stream page
const streamPage = new StreamPage();

// Update confidence slider display
document.getElementById('confidence-slider')?.addEventListener('input', function() {
	document.getElementById('confidence-value').textContent = this.value;
});
{% endblock %}